function u=StokesScloseeval(x, s, side)
% STOKESSCLOSEEVAL - evaluate Stokes SLP potential due to smooth closed curve
%
% u = StokesSevalclose(x,s,tau,side) returns potentials at targets x due to
%  single-layer potential with density sigma living on curve s.
%  The SLP is broken down into 3 Laplace SLP potential calls,
%  each of which are evaluated with the globally-compensated scheme.
%  "side" controls whether targets are inside (default) or outside.
%  (A mixture isn't allowed).
%
% [u n_nat] = StokesSevalclose(x,s,tau,side) also outputs the native (standard
%  trapezoid rule) potential evalation.
%
% Inputs:
% x = M-by-1 list of targets in complex plane 
% s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     s.a one interior point far from bdry (mean(s.x) used if not provided).
% sigma = single-layer density values (N-by-1) at nodes, in complex notation:
%     real, imag contains the 1,2 vector components.
% side = 'i','e' (default) to indicate targets are all interior or exterior
%     to the curve.
%
% Outputs:
% u = velocity values at targets x (M-by-1): real, imag contains 1,2 components
%
% needs: lapSevalclose.m
%
% Also see: QUADR, testStokesSDevalclose.m
%
% (c) Bowei Wu, Sept 2014. Tweaks by Barnett 10/8/14

if nargin<4, side = 'e'; end   % default
% sigmac = sigma(1:end/2)+1i*sigma(end/2+1:end);

N = numel(s.x); M = numel(x);
% find I_1
% tau = real(sigma);
[I1x10, I3x10, I3x20] = lapSevalcloseF(x, s, [], side);

u=1/2*[I1x10+I3x10.*(ones(M,1)*real(s.x)'-real(x)*ones(1,N)),...
    I3x10.*(ones(M,1)*imag(s.x)'-imag(x)*ones(1,N));...
    I3x20.*(ones(M,1)*real(s.x)'-real(x)*ones(1,N)),...
    I1x10+I3x20.*(ones(M,1)*imag(s.x)'-imag(x)*ones(1,N))];
    
% % tau = imag(sigma);
% % [I1x2, I4x1, I4x2] = lapSevalclose(x, s, tau, side);
% I1=1/2*[I1x10,zeros(M,N);zeros(M,N),I1x10];
% %I1=I1(1:end/2)+1i*I1(end/2+1:end);
% 
% 
% tau = imag(sigma);
% % I1x2=I1x2*tau;
% I4x1=I3x10*tau;
% I4x2=I3x20*tau;
% 
% tau = real(sigma);
% % I1x1=I1x1*tau;
% I3x1=I3x10*tau;
% I3x2=I3x20*tau;
% % 
% % 
% 
% % I1 = (I1x1+1i*I1x2)/2;
% 
% % find I_2
% % tau = real(s.x.*conj(sigma));
% %[~, I2x1, I2x2] = lapSevalclose(x, s, tau, side);
% % I2x1=I3x10*tau;
% % I2x2=I3x20*tau;
% % I2 = (I2x1+1i*I2x2)/2;
% I2=1/2*[I3x10.*(ones(M,1)*real(s.x)'),I3x10.*(ones(M,1)*imag(s.x)');I3x20.*(ones(M,1)*real(s.x)'),I3x20.*(ones(M,1)*imag(s.x)')];
% %I2=I2(1:end/2)+1i*I2(end/2+1:end);
% 
% % find I_3
% % I3 = real(x).*(I3x1+1i*I3x2)/2;
% 
% % find I_4
% % I4 = imag(x).*(I4x1+1i*I4x2)/2;
% 
% I34=1/2*[I3x10.*(real(x)*ones(1,N)),I3x10.*(imag(x)*ones(1,N));I3x20.*(real(x)*ones(1,N)),I3x20.*(imag(x)*ones(1,N))];
% 
% % Stokes SLP
% %u = I1+I2-I3-I4;
% u=(I1+I2-I34);
% max(max(abs(u-u2)))

% if nargout>1
%     % 'u_nat' is the native evaluation of SLP
%     t.x = x;
%     sigma = [real(sigma);imag(sigma)];
%     ug_temp = SLPmatrix(t,s)*sigma;  % native eval u
%     u_nat = ug_temp(1:end/2) + 1i * ug_temp(end/2+1:end);
% end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% end main %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% for u_nat testing only:
